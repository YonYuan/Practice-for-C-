#pragma once
#include "pch.h"
#include <iostream>
#include "StrBlob.h"
#include "String.h"
#include "HasPtr.h"
#include "numbered.h"
#include "Employee.h"

using namespace std;

//13.1
//1：在定义一个类时，我们可以显式或隐式的定义在此类型的对象拷贝、赋值、移动、销毁是做什么，主要通过五种特殊的成员函数来完成这些操作：拷贝构造函数、拷贝复制运算符、移动构造函数、移动复制运算符。析构函数
//
//2：拷贝和移动构造函数定义了当用同类型的一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时的操作
//
//3：若一个类没有显式的定义这五个操作，编译器会自动为其定义缺失的操作，在定义一个类时，拷贝控制操作是非常的重要的
//
//4：拷贝构造函数：本身是一个构造函数，其参数是一个自身类类型的引用，且任何额外参数皆有默认值
//
//5：每个成员的类型决定了它的拷贝方式，对于类类型，将调用其拷贝构造函数进行拷贝，对于内置类型，则会直接拷贝，对于数组的拷贝是逐个元素的拷贝，若数组的元素是类类型，则使用拷贝构造函数来拷贝
//
//6：直接初始化：一对小括号加参数。拷贝初始化：等号右侧对象拷贝到正在创建的对象中，如果需要还需进行类型转换(拷贝初始化没有 = 号的情况：将一个对象作为实参传递给一个非引用类型的形参时、从一个返回类型非引用类型的函数返回一个对象、用花括号初始化列表初始化一个数组的元素或一个聚合类的成员)
//
//7：函数的调用中，非引用类型的参数都要进行拷贝初始化。非引用类型的返回值也会被用来初始化调用方的结果

//13.2
//此为一个类的拷贝构造函数，作为函数其非引用类型的参数需要进行拷贝初始化，但拷贝初始化又要调用拷贝构造函数以拷贝实参，但为了拷贝实参又需要调用拷贝构造函数，无限循环。


void func13_3() {
	COUTSTR(__FUNCTION__);
	StrBlob strorig({ "a","bc","def" });
	StrBlob str_copyfun = { "a","bc","def" };

	StrBlobPtr pstrorig(strorig);
	StrBlobPtr pstr_copyfun = strorig;

	return;
}

//13.4：
//首先foo_bar函数的参数为非引用类型，需拷贝，使用拷贝构造函数、函数的返回类型非引用，也需要进行拷贝，使用拷贝构造函数。
//
//在函数体中arg拷贝到local对象，global拷贝到heap对象，local、*heap拷贝到pa[4]中皆使用拷贝构造函数
//
//local拷贝到*heap为拷贝赋值运算符


//StrBlob中元素复制，且智能指针计数加一。StrBlobStr中元素复制，弱指针复制不影响计数器
void func13_7() {
	COUTSTR(__FUNCTION__);
	StrBlob strorig({ "a","bc","def" });
	StrBlob str_copyoper = strorig;

	StrBlobPtr pstrorig(strorig);
	StrBlobPtr pstr_copyoper = pstrorig;

	return;
}

void func13_8() {
	COUTSTR(__FUNCTION__);
	HasPtr has;
	HasPtr has2(has);
	HasPtr has3(has);
	has3 = has2;
	return;
}

//13.9
//
//1：构造函数初始化对象的非static数据成员，析构函数释放对象所使用资源，并销毁对象的非static数据成员
//
//2：形式：波浪号加类名
//
//3：构造函数中，成员初始化是在函数体执行之前完成的，且按照他们在类内出现的顺序进行初始化，析构函数中，首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁，所以析构函数可以执行设计者想要的任何收尾工作，再销毁成员
//
//4：成员的销毁完全依赖于其本身的类型，类类型需要执行自身的析构函数，而内置类型则什么也不做(无析构函数)
//
//5：调用析构函数的情况：
//
//		1：变量离开作用域时被销毁
//		
//		2：当对象被销毁，其成员被销毁
//		
//		3：容器被销毁，成员被销毁
//		
//		4：动态分配的对象，指针被delete时
//		
//		5：临时对象，创建的完整表达式结束时
//
//6：合成析构函数―编译器自动生成的析构函数，基本上为空，或者被用来阻止对象被销毁
//
//7：析构函数体自身并不直接销毁成员，是在析构函数体执行完毕之后隐式的析构阶段中被销毁的

//所有对象的数据成员被销毁，智能指针的计数减一，所有对象的数据成员被销毁，弱指针不影响计数器

//该调用函数末尾执行了s的析构，因为s是一个拷贝
//同时如果拷贝构造函数改变了值，则输出会改变
void f(numbered s) { cout << s.mysn << endl; }

//引用则会避免该问题
void f2(const numbered& s) { cout << s.mysn << endl; }

//13.17
void func13_13() {
	COUTSTR(__FUNCTION__);
	numbered a(12), b = a, c = b;
	//f(a);
	//f(b);
	//f(c);
	f2(a);
	f2(b);
	f2(c);
	return;
}

//13.14
//知识点：这五种操作通常被视为一个整体，一般来说都会一起出现
//
//知识点2：需要析构函数的类也需要拷贝和赋值操作，合成的析构函数不会delete一个指针数据成员，所以有时我们需要自己定义一个析构函数释放构造函数分配的内存，所以需要析构函数的类，也就需要拷贝构造函数和拷贝赋值运算符，而合成的拷贝构造函数和拷贝赋值运算符只能简单的拷贝指针成员，这就意味着多个对象指向同一个内存，释放多个对象时，造成多次delete
//
//知识点3：如果一个类需要自定义版本的析构函数，那么肯定是需要自定义的拷贝构造函数和拷贝赋值运算符
//
//知识点4：拷贝操作和复制操作是相互结合的，如果需要一种，也需要另一种，但不一定意味着需要析构函数

//18,19
void func13_18() {
	COUTSTR(__FUNCTION__);

	Employee a, b, c;
	a.printID();
	b.printID();
	c.printID();

	return;
}

//1：我们可以通过将拷贝控制成员定义为 = default 来显式的要求编译器生成合成的版本(只能对有合成版本的函数使用)，在此之后，合成的函数将隐式的声明为内联
//
//2：iostream类阻止了拷贝，避免多个对象同时写入，或读取相同的IO缓冲，我们可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝，虽然声明了他们，但不能以任何的方式使用他们，在参数列表之后加上 = delete 来指出我们希望其是被删除的，这是为了通知编译器，我们不希望这些函数被定义
//
//3：可以对任何类内函数(析构函数除外)声明 = delete ，且必须出现在函数第一次声明的时候，如果析构函数被声明 = delete ，析构函数被删除，就无法销毁此类型的对象
//
//4：本质上，当不可能拷贝、赋值、销毁类的成员时，类的拷贝构造函数会被定义为删除的
//
//5：C++11之前，是将拷贝构造函数和拷贝赋值运算符定义为private来阻止拷贝的(旧标准)

//13.21：
//知识点：判断一个类是否需要拷贝控制函数成员，首先判断其是否需要自定义版本的析构函数，
//如果需要，则拷贝控制成员函数都需要。由于这两个类中的指针为智能指针，可以自动控制内存的释放，
//所以使用类的合成析构函数即可。
//另外类默认的拷贝控制成员对于智能指针的拷贝也不需要自定义版本来修改，
//所以全部定义为 = default 即可

//13.22：
//1：管理类外资源的类必须定义拷贝控制成员
//
//2：为了定义拷贝控制成员，我们可以定义拷贝操作，使得类的行为看起来像是一个值或者一个指针
//
//3：类的行为像一个值，拷贝发生时，副本和原对象是完全独立的，改变副本不会对原对象产生影响
//
//4：类的行为像一个指针，拷贝发生时，副本和原对象共用底层数据，改变副本也会改变原对象
//
//5：标准库容器和string类就是像值的类，shared_ptr类就是像指针的类，IO类和unique_ptr不允许拷贝和赋值，所以都不是

//13.23：
//知识点1：类值版本，类的构造函数需要可能需要动态分配其成员的副本
//
//知识点2：类值版本，类的拷贝赋值运算符相当于结合了构造函数和析构函数的操作，
//首先销毁左侧运算对象的资源，再从右侧运算符对象拷贝资源，注意顺序
//
//知识点3：由于有上述的顺序存在，所以我们必须保证这样的拷贝赋值运算符是正确的：
//首先将右侧运算对象拷贝到一个临时的对象中，再销毁左侧的运算对象的现有成员，之后将临时对象中的数据成员拷贝至左侧对象中(防范自赋值的情况发生―首先就销毁了自身的成员，再进行拷贝自身则会访问到已经释放的内存中)

//13.24：
//未定义析构函数，ps在使用结束后不会被合成版本的析构函数释放，
//
//造成内存泄漏。未定义拷贝构造函数，使用自定义版本的拷贝构造函数，
//
//对于ps的拷贝就会是指针本身的拷贝。

//13.25
//动态分配的内存由shared_ptr管理，析构函数之后会自动判断进行释放，所以不需要自定义版本的析构函数。

//13.26：
//1：定义行为像指针的类，在不想使用shared_ptr的情况下我们可以使用引用计数来确定是否释放内存
//
//2：每个构造函数(拷贝构造函数除外)都创建一个引用计数，记录对象的共享状态，第一次被新建时，计数为1
//
//3：析构函数递减引用计数，拷贝赋值运算符递增右侧对象的引用计数，递减左侧的，当左侧的引用计数为0时，拷贝赋值运算符就必须销毁状态
//
//4：计数器不能直接作为类对象的成员，否则在拷贝中，会出现歧义，我们可以将计数器保存在动态内存中，只定义一个指向计数器的指针，这样拷贝或者赋值时，我们拷贝该指针，副本和原对象指向同样的计数器

void func13_27() {
	COUTSTR(__FUNCTION__);
	HasPtr has;
	HasPtr has2(has);
	HasPtr has3(has);
	has3 = has2;
	return;
}

//13.29
//1：如果一个类定义了自己的swap，那么算法将利用类自己的版本(重排顺序等算法)
//
//2：自定义版本的swap存在的必要性：我们不希望进行新的内存分配，只希望将其指针进行拷贝赋值(交换的本质)，省去不必要的内存分配，将函数定义为friend，以便访问private成员
//
//3：相对于拷贝控制成员，swap并不是不要的，但是对于那些分配了资源的类，定义swap可能是一种很重要的优化手段
//
//4：swap函数自定义版本与std中版本的重合问题：对于swap函数，其调用应该都是不加限定的，若加std::swap则调用的是标准库的版本，而标准库的版本在一定程度上是为了那些内置类型没有自定义版本的swap而准备的，若一个类有其自定义版本的swap函数，则我们就不应该使用std版本的。所以我们只要在前加上using std::swap声明，即可，在使用中，若有类特定的swap，其匹配程度则会优于std中的版本(616页有详解)
//
//5：在赋值运算符中使用swap，以传值的方式传入新对象，再进行拷贝赋值，在一定程度上会比较安全


class TreeNode {
public:
	TreeNode() :left(new TreeNode), right(new TreeNode) {};
	TreeNode(std::string str,int co) :value(str),cont(co),left(new TreeNode), right(new TreeNode) {};

	TreeNode(const TreeNode& node) :value(node.value), cont(node.cont), left(new TreeNode(*node.left)), right(new TreeNode(*node.right)) {};
	TreeNode& operator=(const TreeNode& node) {
		value = node.value;
		cont = node.cont;
		auto t_lnode = node.left;
		delete left;
		left = t_lnode;

		auto t_rnode = node.left;
		delete right;
		right = t_rnode;
	};

private:
	std::string value;
	int cont;
	TreeNode *left;
	TreeNode *right;
};

class BinStrTree {
private:
	TreeNode *root;
};

void func13_29() {
	COUTSTR(__FUNCTION__);
	vector<HasPtr> vec1;
	HasPtr a("l");
	HasPtr b("llll");
	HasPtr c("lll");
	HasPtr d(a);

	//对于类指针的版本，自带swap即可
	swap(a, b);//是用编译器自带的swap

	vec1.push_back(a);
	vec1.push_back(b);
	vec1.push_back(c);
	vec1.push_back(d);
	vector<HasPtr>::iterator it1 = vec1.begin();
	sort(vec1.begin(), vec1.end());
	show(vec1);


	return;
}

//1：新标准的特性：可以移动而非拷贝对象，可直接调用std::move()，移动而非拷贝会大幅度的提高性能：不必要进行旧内存到新内存的拷贝，当对象很大时省下很多的内存，另一个原因是像IO类和unique_ptr这样的类不可以进行拷贝，但是我们可以使用移动来共享其中的资源
//
//2：右值引用：必须绑定到右值的引用通过两个取址符号&&来获得右值引用：只绑定到一个将要销毁的对象，因此，我们可以自由的将右值引用的资源“移动”到另一个对象中
//
//3：左值和右值的区别：P121页
//
//4：一个右值引用本质上也只是一个对象的另外一个名字而已。对于常规的引用：称之为左值引用，我们不能将其绑定到所要转换的表达式，而右值引用可以绑定
//
//5：左值持久，右值短暂，左值具有持久的状态，右值要么是字面值常量，要么是在表达式求值的过程中创建的临时对象(没有其他用户进行绑定且要被销毁)：使用右值引用的代码可以自由的接管所引用的对象的资源
//
//6：变量是左值

//13.46
//(a)：f()为函数的返回值，临时值，属于右值， &&
//
//(b)：vi[0]为变量，属于左值，&
//
//(c)：r1为变量，属于左值，&
//
//(d)：右侧为表达式，属于右值，&&

void func13_47() {
	COUTSTR(__FUNCTION__);

	vector<String> vec;
	String s1("hello");
	String s2 = s1;
	vec.push_back(s1);
	vec.push_back(s2);

	s1.show();
	s2.show();
	vec[0].show();
	vec[1].show();

	return;
}

void Practice_13() {
	COUTSTR(__FUNCTION__);
	func13_47();
}